import numpy as np
from django.core.cache import cache


def ho_kashyap_algorithm(V, max_iter=1000, h=0.1, tol=1e-5):
    """
    Реалізація алгоритму Хо-Кашьяпа для лінійно роздільних класів.

    Параметри:
    - V: матриця ознак (де кожен рядок відповідає вектору даних).
    - max_iter: максимальна кількість ітерацій.
    - h: крок оновлення для вектора y.
    - tol: допуск для умови зупинки.

    Повертає:
    - w: ваговий вектор, що розділяє класи.
    - k: кількість ітерацій.
    """

    V = modify_data(V)

    # Кількість рядків (N) і стовпців (розмірність ознак)
    N, d = V.shape

    # Ініціалізація векторів
    y = np.ones(N)  # Вибираємо початковий y з додатними координатами
    V_dagger = np.linalg.pinv(V)  # Псевдообернена матриця до V
    w = V_dagger @ y  # Початковий ваговий вектор

    # Ітеративний процес
    for k in range(max_iter):
        # Перевірка умови зупинки: якщо всі компоненти Vw > 0
        if np.all(V @ w > -tol):
            print("Алгоритм завершився на ітерації:", k)
            return w, k

        # Оновлення вектора y
        y = y + h * np.maximum(0, -V @ w)

        # Оновлення вектора w
        w = V_dagger @ y

    print("Алгоритм не зійшовся за максимальну кількість ітерацій")
    return w, max_iter

# Функція для модифікації даних
def modify_data(V):
    # Додавання стовпця одиниць
    ones_column = np.ones((V.shape[0], 1))
    V = np.hstack((V, ones_column))  # Додаємо стовпець одиниць

    # Інвертуємо координати для другої половини матриці
    mid_index = len(V) // 2  # визначаємо середину
    V[mid_index:] = -V[mid_index:]  # Інвертуємо координати для другої половини

    return V